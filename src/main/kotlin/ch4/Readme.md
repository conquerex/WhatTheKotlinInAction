# 4장. 클래스, 객체, 인터페이스

## 입구

- 클래스와 인터페이스
- 뻔하지 않은 생성자와 프로퍼티
- 데이터 클래스
- 클래스 위임
- object 키워드 사용

코틀린의 클래스와 인터페이스는 자바의 것과는 약간 다르다. 예를 들어, **인터페이스**에 프로퍼티 선언이 들어갈 수 있다. 자바와 달리 **코틀린의 선언**은 기본적으로 final이며 public이다. 게다가 중첩
클래스는 기본적으로는 내부 클래스가 아니다. 즉, 코틀린 중첩 클래스에는 외부 클래스에 대한 참조가 없다.

짧은 주 생성자 구문으로도 거의 모든 경우를 잘 처리할 수 있지만, 복잡한 초기화 로직을 수행하는 경우를 대비해 완전한 문법도 있다. 프로퍼티도 마찬가지로 간결한 구문으로 충분히 제 기능을 하지만, 필요하면 **
접근자를 직접 정의**할 수 있다.

코틀린 컴파일러는 번잡스러움을 피하기 위해 유용한 메서드를 자동으로 만들어준다.
**클래스를 data로** 선언하면 일부 표준 메서드를 생성해준다.

그리고 코틀린 언어가 제공하는 **위임**(delegation)을 사용하면 위임을 처리하기 위한 준비 메서드를 직접 작성할 필요가 없다.

또한 클래스와 인스턴스를 동시에 선언하면서 만들 때 쓰는 **object** 키워드에 대해 알아본다. 싱글턴 클래스, 동반 객체(companion object), 객체 식(object expression = java
익명 클래스)을 표현할 때 사용한다.


<br/>

## 4.1. 클래스 계층 정의

## 4.1.1. 코틀린 인터페이스

코틀린 인터페이스는 자바8 인터페이스와 비슷하다. 코틀린 인터페이스 안에는 추상 메서드뿐 아니라 구현이 있는 메서드(자바8의 디폴트 메서드와 비슷하다)도 정의할 수 있다. 다만 인터페이스에는 아무런 상태(필드)도
저장될 수 없다.

```kotlin
// 인터페이스 정의
interface Clickable {
    fun click()
}

// 구현
class Button : Clickable {
    override fun click() = println("I was clicked")
}
```

자바에서는 `extends`와 `implements` 키워드를 사용하지만, 코틀린에서는 클래스 이름 뒤에 콜론을 붙이는 것으로 확장과 구현을 모두 처리한다. 자바와 마찬가지로 클래스는 인터페이스를 원하는 만큼
마음대로 구현(implements)할 수 있지만, 클래스는 오직 하나만 확장(extends)할 수 있다.

자바의 @Override 애노테이션과 비슷한 `override` 변경자는 상위 클래스나 상위 인터페이스에 있는 프로퍼티나 메서드를 재정의 한다는 뜻이다. 하지만 자바와 달리 코틀린에서는 override 변경자를
반드시 사용해야 한다. 이는 실수로 상위 클래스의 메서드를 오버라이드 하는 경우를 방지해준다.

상위 클래스에 있는 메서드와 시그니처가 같은 메서드를 우연히 하위 클래스에서 선언하는 경우 컴파일이 안되기 때문에 override를 붙이거나 메서드 이름을 바꿔야만 한다.

인터페이스 메서드도 디폴트 구현을 제공할 수 있다. default를 붙여야하는 자바와 달리 그냥 메서드 본문을 추가하면 된다. 이 인터페이스를 구현하는 클래스는 click에 대한 구현을 제공해야 하는 반면,
showOff 메서드의 경우 재정의할 수도 있고, 디폴트 구현을 사용할 수도 있다.

```kotlin
interface Clickable {
    fun click() // 일반 메소드 선언
    fun showOff() = println("I'm clickable!") // 디폴트 구현이 있는 메소드
}
```

한 클래스에서 이 두 인터페이스를 함께 구현하면 (이 경우에는 showOff 메소드) 어떻게 될까? 정답은 어느 쪽도 선택되지 않는다. 클래스가 구현하는 두 상위 인터페이스에 정의된 구현을 대체할 오버라이딩 메서드를
직접 제공하지 않으면 컴파일러 오류가 발생한다.

```
Class 'Button' must override public open fun showOff(): 
Unit defined in ch4.Clickable because it inherits multiple interface methods of it
```

코틀린 컴파일러는 두 메서드를 아우르는 구현을 하위 클래스에 직접 구현하게 강제한다.

```kotlin
class Button : Clickable, Focusable {
    override fun click() = println("I was clicked")

    // 이름과 시그니처가 같은 멤버 메소드에 대해 둘 이상의 디폴트 구현이 있는 경우
    // 인터페이스를 구현하는 하위 클래스에서 명시적으로 새로운 구현을 제공해야 한다.
    override fun showOff() {
        // 상위 타입의 이름을 (제네릭) 꺾쇠 괄호 사이에 넣어서 super를 지정하면
        // 어떤 상위 타입의 멤버 메소드를 호출할지 지정할 수 있다.
        super<Clickable>.showOff()
        super<Focusable>.showOff()
    }
}
```

Button은 상속한 두 상위 타입의 showOff() 메서드를 호출하는 방식으로 showOff()를 구현한다. 
상위 타입의 구현을 호출할 때는 자바와 마찬가지로 `super`를 사용한다. 
하지만 구체적으로 타입을 지정하는 문법은 다르다. 
자바에서는 Clickable.super.showOff() 처럼 super 앞에 기반 타입을 적지만, 
코틀린에서는 super<Clickable>.showOff()처럼 꺾쇠 괄호 안에 기반 타입 이름을 지정한다.

상속한 구현 중 단 하나만 호출해도 된다면 다음과 같이 쓸 수도 있다.

```kotlin
override fun showOff() = super<Clickable>.showOff()
```

아래 코드에서 Button 클래스는 Focusable 인터페이스 안에 선언된 setFocus의 구현을 자동으로 상속한다.

```kotlin
val button = Button()
button.showOff()
button.setFocus(true)
button.click()
```

> #### ✅자바에서 코틀린의 메소드가 있는 인터페이스 구현하기
> 코틀린은 자바 6와 호환되게 설계됐다. 따라서 인터페이스의 디폴트 메서드를 지원하지 않는다. 
> 따라서 코틀린은 디폴트 메서드가 있는 인터페이스를 
> 일반 인터페이스와 디폴트 메서드 구현이 정적 메서드로 들어있는 클래스를 조합해 구현한다. 
> 
> 인터페이스에는 메서드 선언만 들어가며, 인터페이스와 함께 생성되는 클래스에는 모든 디폴트 메서드 구현이 정적 메서드로 들어간다. 
> 그러므로 디폴트 인터페이스가 포함된 코틀린 인터페이스를 자바 클래스에서 상속해 구현하고 싶다면 
> 코틀린에서 메서드 본문을 제공하는 메서드를 포함하는 모든 메서드에 대한 본문을 작성해야 한다. 
> (즉 자바에서는 코틀린 디폴트 메서드 구현에 의존할 수 없다) (필자: 따로 구현이 필요하다는 뜻인가?)

<br/>

## 4.1.2. open, final, abstract 변경자: 기본적으로 final



<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
