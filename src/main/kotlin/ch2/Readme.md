# 2장. 코틀린 기초

## 입구

* 변수 variable
* 함수 function
* 클래스 class
* 프로퍼티 property
* 대부분의 코틀린 제어 구조는 자바와 비슷하지만 몇 가지 주용한 개선이 이루어졌다
* 스마트 캐스트 smart cast : 타입 검사와 타입 캐스트, 타입 강제 변환을 하나로 엮은 기능
* 예외 처리 exception handling
* 여기서 배운 내용만으로 작성할 수 있는 코드는 코틀린다운 코드라고 부르기는 어렵다

## 2.1 기본 요소: 함수와 변수
### 2.1.1 Hello, World

```kotlin
fun main(args: Array<String>) {
	println("Hello, World!")
}
  ```

- 함수를 선언할 때 fun 키워드를 사용한다.
- 파라미터 이름 뒤에 타입을 쓴다.
- 클래스 안에 함수를 넣어야 할 필요가 없고, 함수를 최상위 수준에 정의할 수 있다.
- 자바와는 달리 배열 처리를 위한 문법이 따로 존재하지 않는다.
- 자바의 System.out.println 대신 `println`을 사용한다.
  - 코틀린 표준 라이브러리는 여러가지 표준 자바 라이브러리 함수를 간결하게 사용할 수 있게 감싸나 래퍼(wrapper)를 제공


### 2.1.2 함수
의미 있는 결과를 반환하는 함수의 경우 반환 값의 타입을 어디에 지정해야 할까? 코틀린 REPL에서 확인해보자
```
➜  WhatTheKotlinInAction git:(main) ✗ kotlinc
Welcome to Kotlin version 1.5.31 (JRE 11.0.11+9-LTS)
Type :help for help, :quit for quit
>>> fun max(a: Int, b: Int): Int {
...     return if (a > b) a else b
... }
>>> println(max(11, 22))
22
```

> 콘솔 화면에서 파이썬 구문을 입력하면 바로 결과를 반환하고 다시 입력할수 있는 도구. 
> 
> Read Evaluate Print Loop의 줄임말

kotlinc를 실행하면 버전 정보가 표시된 후 `>>>` 프롬프트가 표시 <br>
사용자가 입력한 문장이 완전히 끝나지 않으면 REPL은 `...`을 표시해서 뒷부분을 더 입력받는다.

함수 선언은 fun 키워드로 시작, 그 다음에는 함수의 이름이 온다. <br>
함수 이름 뒤에는 괄포 안에 파라미터 목록이 온다. <br>
함수의 반환 타입은 파라미터 목록의 닫는 괄호 다음에 오는데, 괄호와 반환 타입 사이를 콜론`:`으로 구분.
<img width="801" alt="스크린샷 2021-09-12 23 25 07" src="https://user-images.githubusercontent.com/52916061/132991442-fddf16de-ce5b-4b17-9936-eaad93cc55b2.png">

> ✅문(statement)과 식(expression)의 구분 <br>
> 코틀린에서 if는 식 (문이 아님)
> **식**은 값을 만들어 내며 다른 식의 하위 요소로 계산에 참여할 수 있다.
> **문**은 자신을 둘러싸고 있는 가장 안쪽 블록의 최상위 요소로 존재하며 아무런 값을 만들어내지 않는다.
> 자바에서는 모든 제어 구조가 문인 반면, 코틀린에서는 루프를 제외한 대부분의 제어 구조가 식이다. <br>
> 대입문은 자바에서는 식이었으나 코틀린에서는 문.
> 자바와 달리 대입식과 비교식을 잘못 바꿔 써서 버그가 생기는 경우가 없다.

### 식이 본문인 함수
앞에서 살펴본 함수를 더 간결하게 표현 가능. if 식 하나로만 이뤄져 있는데, 중괄호를 없애고 return을 제거하면서 등호를 식 앞에 붙이면 더 간결하게 함수를 표현할 수 있다.

```kotlin
fun max(a: Int, b: Int): Int = if (a>b) a else b
```

본문이 중괄호로 둘러싸인 함수를 `블록이 본문인 함수`, 등호와 식으로 이뤄진 함수를 `식이 본문인 함수`라고 한다. 코틀린에서는 식이 본문이 함수가 자주 쓰인다. 그런 함수의 본문 식에는 단순한 산술식이나 함수 호출 식뿐 아니라 if, when, try 등의 더 복잡한 식도 자주 쓰인다.

반환 타입을 생략하면 max 함수를 더 간략하게 만들 수 있다.

```kotlin
fun max(a: Int, b: Int) = if (a>b) a else b
```

코틀린은 정적 타입 지정 언어이므로 컴파일 시점에 모든 식의 타입을 지정해야 하는데, 여기서 반환 타입을 생략할 수 있는 이유?

실제로 모든 변수나 모든 식에는 타입이 있으며, 모든 함수는 반환 타입이 정해져야 한다. 하지만 **식이 본문인 함수의 경우 굳이 사용자가 반환 타입을 적지 않아도 컴파일러가 함수 본문 식을 분석해서 식의 결과 타입을 함수 반환 타입으로 정해준다.** 이렇게 컴파일러가 타입을 분석해 프로그래머 대신 프로그램 구성 요소의 타입을 정해주는 기능을 `타입 추론(type inference)`이라 부른다.

식이 본문이 함수의 반환 타입만 생략 가능하다는 점에 유의해야 한다. 블록이 본문인 함수가 값을 반환한다면 반드시 반환 타입을 지정하고 return문을 사용해 반환 값을 명시해야 한다. return문이 여럿 들어가는 경우. 함수가 어떤 타입의 값을 반환하고 어디서 그런 값을 반환하는지 더 쉽게 알아볼 수 있다.

### 2.1.3 변수
