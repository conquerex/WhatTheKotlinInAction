# 2장. 코틀린 기초

## 입구

* 변수 variable
* 함수 function
* 클래스 class
* 프로퍼티 property
* 대부분의 코틀린 제어 구조는 자바와 비슷하지만 몇 가지 주용한 개선이 이루어졌다
* 스마트 캐스트 smart cast : 타입 검사와 타입 캐스트, 타입 강제 변환을 하나로 엮은 기능
* 예외 처리 exception handling
* 여기서 배운 내용만으로 작성할 수 있는 코드는 코틀린다운 코드라고 부르기는 어렵다

## 2.1 기본 요소: 함수와 변수
### 2.1.1 Hello, World

```kotlin
fun main(args: Array<String>) {
	println("Hello, World!")
}
  ```

- 함수를 선언할 때 fun 키워드를 사용한다.
- 파라미터 이름 뒤에 타입을 쓴다.
- 클래스 안에 함수를 넣어야 할 필요가 없고, 함수를 최상위 수준에 정의할 수 있다.
- 자바와는 달리 배열 처리를 위한 문법이 따로 존재하지 않는다.
- 자바의 System.out.println 대신 `println`을 사용한다.
  - 코틀린 표준 라이브러리는 여러가지 표준 자바 라이브러리 함수를 간결하게 사용할 수 있게 감싸나 래퍼(wrapper)를 제공


### 2.1.2 함수
의미 있는 결과를 반환하는 함수의 경우 반환 값의 타입을 어디에 지정해야 할까? 코틀린 REPL에서 확인해보자
```
➜  WhatTheKotlinInAction git:(main) ✗ kotlinc
Welcome to Kotlin version 1.5.31 (JRE 11.0.11+9-LTS)
Type :help for help, :quit for quit
>>> fun max(a: Int, b: Int): Int {
...     return if (a > b) a else b
... }
>>> println(max(11, 22))
22
```

> 콘솔 화면에서 파이썬 구문을 입력하면 바로 결과를 반환하고 다시 입력할수 있는 도구. 
> 
> Read Evaluate Print Loop의 줄임말

kotlinc를 실행하면 버전 정보가 표시된 후 `>>>` 프롬프트가 표시 <br>
사용자가 입력한 문장이 완전히 끝나지 않으면 REPL은 `...`을 표시해서 뒷부분을 더 입력받는다.

함수 선언은 fun 키워드로 시작, 그 다음에는 함수의 이름이 온다. <br>
함수 이름 뒤에는 괄포 안에 파라미터 목록이 온다. <br>
함수의 반환 타입은 파라미터 목록의 닫는 괄호 다음에 오는데, 괄호와 반환 타입 사이를 콜론`:`으로 구분.
<img width="801" alt="스크린샷 2021-09-12 23 25 07" src="https://user-images.githubusercontent.com/52916061/132991442-fddf16de-ce5b-4b17-9936-eaad93cc55b2.png">

> ✅문(statement)과 식(expression)의 구분<br>
> 코틀린에서 if는 식 (문이 아님)
> **식**은 값을 만들어 내며 다른 식의 하위 요소로 계산에 참여할 수 있다.
> **문**은 자신을 둘러싸고 있는 가장 안쪽 블록의 최상위 요소로 존재하며 아무런 값을 만들어내지 않는다. (분기문, 반복문)
> 자바에서는 모든 제어 구조가 문인 반면, 코틀린에서는 루프를 제외한 대부분의 제어 구조가 식이다. <br>
> 대입문은 자바에서는 식이었으나 코틀린에서는 문.
> 자바와 달리 대입식과 비교식을 잘못 바꿔 써서 버그가 생기는 경우가 없다.

### 식이 본문인 함수
앞에서 살펴본 함수를 더 간결하게 표현 가능. if 식 하나로만 이뤄져 있는데, 중괄호를 없애고 return을 제거하면서 등호를 식 앞에 붙이면 더 간결하게 함수를 표현할 수 있다.

```kotlin
fun max(a: Int, b: Int): Int = if (a>b) a else b
```

본문이 중괄호로 둘러싸인 함수를 `블록이 본문인 함수`, 등호와 식으로 이뤄진 함수를 `식이 본문인 함수`라고 한다. 코틀린에서는 식이 본문이 함수가 자주 쓰인다. 그런 함수의 본문 식에는 단순한 산술식이나 함수 호출 식뿐 아니라 if, when, try 등의 더 복잡한 식도 자주 쓰인다.

반환 타입을 생략하면 max 함수를 더 간략하게 만들 수 있다.

```kotlin
fun max(a: Int, b: Int) = if (a>b) a else b
```

코틀린은 정적 타입 지정 언어이므로 컴파일 시점에 모든 식의 타입을 지정해야 하는데, 여기서 반환 타입을 생략할 수 있는 이유?

실제로 모든 변수나 모든 식에는 타입이 있으며, 모든 함수는 반환 타입이 정해져야 한다. 하지만 **식이 본문인 함수의 경우 굳이 사용자가 반환 타입을 적지 않아도 컴파일러가 함수 본문 식을 분석해서 식의 결과 타입을 함수 반환 타입으로 정해준다.** 이렇게 컴파일러가 타입을 분석해 프로그래머 대신 프로그램 구성 요소의 타입을 정해주는 기능을 `타입 추론(type inference)`이라 부른다.

식이 본문이 함수의 반환 타입만 생략 가능하다는 점에 유의해야 한다. 블록이 본문인 함수가 값을 반환한다면 반드시 반환 타입을 지정하고 return문을 사용해 반환 값을 명시해야 한다. return문이 여럿 들어가는 경우. 함수가 어떤 타입의 값을 반환하고 어디서 그런 값을 반환하는지 더 쉽게 알아볼 수 있다.

### 2.1.3 변수

자바에서는 변수를 선언할 때 타입이 맨 앞에. 코틀린에서는 타입 지정을 생략하는 경우가 흔하다. 
타입으로 변수 선언을 시작하면 타입을 생략할 경우 식과 변수 선언을 구별할 수 없다.(필자 : 이게 무슨 말이야) <br> 
코틀린에서는 키워드로 변수 선언을 시작하는 대신 변수 이름 뒤에 타입을 명시하거나 생략하게 허용한다. <br>

```java
int sample = 1;
```

```kotlin
val question = "질문"
val answer: Int = 123
```

식이 본문인 함수에서와 마찬가지로, 타입을 지정하지 않으면 컴파일러가 **초기화 식을 분석해서 초기화 식의 타입을 변수 타입으로 지정**한다.
부동소수점(floating point) 상수를 사용한다면 변수타입은 Double이 된다. (6.2절에서 더 자세히 다룸) 
초기화 식을 사용하지 않고 변수를 선언하려면 변수 타입을 반드시 명시해야 한다.
초기화 식이 없다면 변수에 저장될 값에 대해 아무 정보가 없기 대문에 컴파일러가 타입을 추론할 수 없다. 그런 경우 타입을 반드시 지정해야 한다.

```kotlin
val answer2: Int
answer2 = 123
```


### 변경 가능한 변수와 변경 불가능한 변수

변수 선언 시 사용하는 키워드 2가지

- **`val`** (값을 뜻하는 value에서 따옴)
  - 변경 불가능한(immutavle) 참조를 저장하는 변수다. 
  - val로 선언된 변수는 일단 초기화하고 나면 재대입이 불가능하다. (자바의 final 변수에 해당)
- **`var`** (변수를 뜻하는 variable에서 따옴)
  - 변경 가능한(mutable) 참조다. 
  - 이런 변수의 값은 바뀔 수 있다. (자바의 일반 변수에 해당)

기본적으로 모든 변수를 val 키워드를 사용해 불변 변수로 선언하고, 나중에 꼭 필요할 때에만 var로 변경하라.

변경 불가능한 참조와 변경 불가능한 객체를 부수 효과가 없는 함수와 조합해 사용하면 코드가 `함수형 코드`에 가까워 진다. <br>
(1장에서는 함수형 스타일의 장점을 간략히. 5장에서는 좀 더 자세히 함수형 프로그래밍에 대해 설명)

val 변수는 블록을 실행할 때 정확히 한 번만 초기화돼야 한다. 하지만 어떤 블록이 실행될 때 오직 한 초기화 문장만 실행됨을 컴파일러가 확인할 수 있다면 조건에 따라 val 값을 다른 여러 값으로 초기화할 수도 있다.

```kotlin
val message: String
if (canPerformOperation()) {
	message = "Success"
	// 연산 수행
} else {
	message = "Failed"
}
```

val 참조 자체는 불변일지라도 그 참조가 가리키는 객체의 내부 값은 변경될 수 있다는 사실을 기억하라.<br>
(6장에서 변경 가능한 객체와 불변 객체에 대해 더 자세히 살펴봄)

```kotlin
val languages = arrayListOf("Java") //불변 참조 선언
languages.add("Kotlin")             //참조가 가리키는 객체 내부를 변경
```

var 키워드를 사용하면 변수의 값을 변경할 수 있지만 변수의 타입은 고정돼 바뀌지 않는다.

```kotlin
var answer = 42
answer = "no answer"  //"Error: type mismatch" 컴파일 오류 발생
```

문자열 리터럴에서 컴파일 오류가 발생한다. 이유는 String 타입이 컴파일러가 기대하는 타입과 다르기 때문이다. **컴파일러는 변수 선언 시점의 초기화 식으로부터 변수의 타입을 추론**하며, 변수 선언 이후 **변수 제대입이 이뤄질 때는 이미 추론한 변수의 타입을 염두에 두고 대입문의 타입을 검사**한다.

어떤 타입의 변수에 다른 타입의 값을 저장하고 싶다면 변환 함수를 써서 값을 변수의 타입으로 변환하거나, 값을 변수에 대입할 수 있는 타입으로 강제 형 변환해야 한다.
(필자 : 지금 다루기에는 중요한게 아님. 6.2.3절에서 다룸)

<br/>


### 2.1.4 더 쉽게 문자열 형식 지정: 문자열 템플릿

사람 이름을 사용해 환영 인사를 출력하는 코틀린 프로그램

```kotlin
fun main(args: Array<String>) {
	val name = if (args.size > 0) args[0] else "Kotlin"
	println("Hello, $name")
}
```

`문자열 템플릿` 이라는 기능. 
이 코드는 name이라는 변수를 선언하고 그 다음 줄에 있는 문자열 리터럴 안에서 그 변수를 사용했다. 
여러 스크립트 언어와 비슷하게 코틀린에서도 변수를 문자열 안에 사용할 수 있다.
**문자열 리터럴의 필요한 곳에 변수를 넣되 변수 앞에 `$`를 추가**해야 한다.

문자열 템플릿은 자바의 문자열 접합 연산("Hello, " + name + "!")과 동일한 기능을 하지만 
좀 더 간결하며 자바 문자열 접합 연산을 사용한 식과 마찬가지로 효율적.
물론 컴파일러는 각 식을 정적(static)으로 검사하기 때문에 
존재하지 않는 변수를 문자열 템플릿 안에서 사용하면 컴파일 오류가 발생한다.

> 컴파일된 코드는 StringBuilder를 사용하고 문자열 상수와 변수의 값을 append로 문자열 빌더 뒤에 추가한다.
> 자바에서 + 연산으로 문자열과 변수를 붙여도 컴파일러는 StringBuilder를 사용하는 바이트 코드를 생성해준다.

$ 문자를 문자열에 넣고 싶으면 `\`를 사용해 $ 문자를 이스케이프(escape) 시켜야 한다.
복잡한 식도 중괄호({})로 둘러싸서 문자열 템플릿 안에 넣을 수 있다.
중괄호로 둘러싼 식 안에서 큰 따옴표를 사용할 수 있고
중괄호로 둘러싼 식 안에서 문자열 템플릿을 사용해도 된다.
(3.5절에서 더 자세히)

> #### ✅한글을 문자열 템플릿에서 사용할 경우 주의할 점 <br>
> 코틀린에서는 자바와 마찬가지로 한글을
> (사실은 한글 뿐 아니라 글자(letter)로 분류할 수 있는 모든 유니코드)
> 식별자에 사용하라 수 있으므로 변수 이름에 한글이 들어갈 수 있다.
> 그런 유니코드 변수 이름으로 인해 문자열 템플릿을 볼 때 오해가 생길 수 있다.
> 
> 예를 등어 'Hello, $name!' --> '$name님 반가와요'라는 문자열로 바꾸고 컴파일해보면 알 수 있다.
> 
> 문자열 템플릿 안에 $로 변수를 지정할 때 변수명 바로 뒤에 한글을 붙여서 사용하면 
> 코틀린 컴파일러는 영문자와 한글을 한꺼번에 식별자로 인식해서 `unresolved reference 오류`를 발생 시킨다.
> 
> 이 문제를 해결하는 방법은 변수 이름을 {}로 감싸는 것. 
> 변수 이름만 사용하더라도 중괄호로 변수명을 감싸는 습관을 들이면 더 좋다.
> 
> 필요할 때 정규식 등을 통해 검색하거나 일괄 변환할 때도 중괄호를 쓴 경우 처리가 더 쉽고,
> 코드를 사람이 읽을 때도 문자열 템플릿 안에서 변수가 쓰인 부분을 더 쉽게 식별할 수 있다.

<br/>

## 2.2 클래스와 프로퍼티

간단한 자바빈(JavaBean) 클래스인 Person을 정의한다. Person에는 name이라는 프로퍼티(property)만 들어있다.

```java
public class Person {
	private final String name;
	
	public Person(String name) {
		this.name = name;
	}

	public String getName() {
		return name;
	}
}
```

필드가 둘 이상으로 늘어나면 생성자인 `Person(String name)`의 본문에서 
파라미터를 이름이 같은 필드에 대입하는 대입문의 수도 늘어난다. <br>
(필자 : 번역이 이상한데 아마 `필드가 늘어나면 생성자의 파라미터도 늘어난다`라는 뜻인듯) <br>`                             
코틀린에서는 그런 필드 대입 로직을 훨씬 더 적은 코드로 작성할 수 있다.

자바-코틀린 변환기는 자바 코드를 같은 일을 하는 코틀린 코드로 자동으로 변환해준다.

```kotlin
class Person(val name: String)
```
멋지다. (필자 : ㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋ) 
이런 유형의 클래스(코드가 없이 데이터만 저장하는 클래스)를 `값 객체(value object)`라 부르며, 
다양한 언어가 값 객체를 간결하게 기술할 수 있는 구문을 제공한다.

자바를 코틀린으로 변환한 결과, public 가시성 변경자가 사라졌음을 확인할 수 있다. 
**코틀린의 기본 가시성은 public**이므로 변경자를 생략할 수 있다.

<br/>

### 2.2.1 프로퍼티

`클래스`라는 개념의 목적은 데이터를 캡슐화(encapsulate)하고 
캡슐화한 데이터를 다루는 코드를 한 주체 아래 가두는 것이다. 
자바에서는 데이터를 필드에 저장하며, 멤버 필드의 가시성은 보통 비공개(private)이다. 
클래스는 자신을 사용하는 클라이언트가 그 데이터에 접근하는 통로로 쓸 수 있는 `접근자 메소드(accessor method)`를 제공한다. 
보통은 필드를 읽기를 위한 게터를, 필드를 변경하게 허용해야 할 경우 세터를 추가 제공할 수 있다. 
세터는 자신이 받은 값을 검증하거나 필드 변경을 다른 곳에 통지하는 등의 로직을 더 가질 수 있다.

자바에서의 필드와 접근자를 묶어 `프로퍼티(property)`라고 부른다. 프로퍼티라는 개념을 활용하는 프레임워크가 많다.
코틀린은 프로퍼티를 언어 기본 기능으로 제공하며, 
**코틀린 프로퍼티는 자바의 필드와 접근자 메소드를 완전히 대신**한다.

클래스에서 프로퍼티를 선언할 때는 앞에서 살펴본 변수를 선언하는 방법과 마찬가지로 val, var을 사용한다.

```kotlin
class Person(
  val name: String, //읽기 전용 프로퍼티. 비공개 필드와 단순한 공개 게터를 만든다.
  var isMarried: Boolean //쓸 수 있는 프로퍼티. 비공개 필드, 공개 게터, 공개 세터를 만든다.
)
```

기본적으로 코틀린에서 프로퍼티를 선언하는 방식은 프로퍼티와 관련 있는 접근자를 선언하는 것이다.
(읽기 전용 프로퍼티의 경우 게터만 선언하며, 변경할 수 있는 프로퍼티의 경우 게터와 세터를 모두 선언한다.)

코틀린은 값을 저장하기 위한 `비공개 필드`와 그 필드에 값을 저장하기 위한 세터, 필드의 값을 읽기 위한 게터로 이뤄진 
간단한 `디폴트 접근자 구현`을 제공한다.

```java
// 위 샘플 다시 가져와서...
public class Person {
	private final String name; // 비공개 필드
	
	public Person(String name) { // 생성자가 그 필드를 초기화
		this.name = name;
	}

	public String getName() { // 게터를 통해 그 필드를 접근
		return name;
	}
}
```

사용하는 방법은 아래와 같다.
```java
Person person = new Person("Bob", true);
System.out.println(person.getName());
-> Bob
System.out.println(person.isMarried());
-> true
```

자바에서 게터와 세터의 이름을 정하는 규칙에는 예외가 있다. 
이름이 is로 시작하는 프로퍼티의 게터에는 get이 붙지 않고 원래 이름 그대로 사용하며, 
세터에는 is를 set으로 바꾼 이름을 사용한다. (확인필요 : 이거 관행 아닌가?)

위 코드를 자바-코틀린 변환기로 변환한 결과는 다음과 같다.

```kotlin
val person = Person("Bob", true) //new 키워드를 사용하지 않음
println(person.name)
-> Bob
println(person.isMarried)
-> true
//프로퍼티 이름을 직접 사용해도 자동으로 게터를 호출해줌
```

코틀린에서는 게터를 호출하는 대신 프로퍼티를 직접 사용했음에 유의하라. 로직은 동일하지만 코드는 더 간결해졌다.

> 자바에서 선언한 클래스에 대해 코틀린 문법을 사용해도 된다.
코틀린에서는 자바 클래스의 게터를 val 프로퍼티처럼 사용할 수 있고, 
게터/세터 쌍이 있는 경우에는 var 프로퍼티처럼 사용할 수 있다.
> - 접근자 setName, getName --> name이라는 프로퍼티 사용
> - 메소드 isMarried, setMarried --> isMarried 프로퍼티

대부분의 프로퍼티에는 그 프로퍼티의 값을 저장하기 위한 필드가 있다. 
이를 프로퍼티를 뒷받침하는 필드(backing field)라고 부른다. 
하지만 원한다면 그때그때 계산할 수도 있다. 커스텀 게터를 작성하면 그런 프로퍼티를 만들 수 있다.

<br/>




<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>