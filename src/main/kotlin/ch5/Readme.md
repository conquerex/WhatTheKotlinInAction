# 5장. 람다로 프로그래밍

## 입구

**람다식 또는 람다는 기본적으로 다른 함수에 넘길 수 있는 작은 코드 조각을 의미**한다.
람다를 주로 사용하는 경우는 컬렉션 처리를 예로 들 수 있겠다.
이 장에서는 컬렉션을 처리하는 패턴을 표준 라이브러리 함수에 람다로 넘기는 방식,
자바 라이브러리와 람다를 함께 사용하는 방법도 살펴본다.
그리고 수신 객체 지정 람다(lambda with receiver)에 대해서도 살펴본다.

<br/>

## 5.1. 람다 식과 멤버 참조

## 5.1.1.  람다 소개: 코드 블록을 함수 인자로 넘기기

"이벤트가 발생하면 이 핸들러를 실행하자"나 "데이터 구조의 모든 원소에 이 연산을 적용하자"와 같은 생각을 
코드로 표현하기 위해 일련의 동작을 변수에 저장하거나 다른 함수에 넘겨야 하는 경우가 자주 있다.
예전에 자바에서는 무명 내부 클래스를 통해 이런 목적을 달성했다.
무명 내부 클래스를 사용하면 코드를 함수에 넘기거나 변수에 저장할 수 있기는 하지만 상당히 번거롭다.

이와 달리 함수형 프로그래밍에서는 함수를 값처럼 다루는 접근 방법을 택함으로써 이 문제를 해결한다.
클래스를 선언하고 그 클래스의 인스턴스를 함수에 넘기는 대신 함수형 언어에서는 함수를 직접 다른 함수에 전달할 수 있다.

람다 식을 사용하면 코드가 더욱 더 간결해진다. 
람다 식을 사용하면 함수를 선언할 필요가 없고 코드 블록을 직접 함수의 인자로 전달할 수 있다.

```java
/* 자바 */
button.setOnClickListener(new onClickListener() {
    @Override
    public void onClick(View view) {
        /* 클릭 시 수행할 동작 */
    }
});
```

무명 내부 클래스를 선언하느라 코드가 번잡스러워졌다.
이와 비슷한 작업을 많이 수행해야 하는 경우 그런 번잡함은 난잡함으로 변해 개발자를 괴롭힌다.
클릭 시 벌어질 동작을 간단히 기술할 수 있는 표기법이 있다면 이런 불필요한 코드를 제거할 수 있을 것이다.

```kotlin
button.setOnClickListener { /* 클릭 시 수행할 동작 */ }
```

이 코틀린 코드는 앞에서 살펴본 자바 무명 내부 클래스와 같은 역할을 하지만 훨씬 더 간결하고 읽기 쉽다.


## 5.1.2. 람다와 컬렉션

코드에서 중복을 제거하는 것은 프로그래밍 스타일을 개선하는 중요한 방법 중 하나다.
컬렉션을 다룰 때 수행하는 대부분의 작업은 몇 가지 일반적인 패턴에 속한다. 
따라서 그런 패턴은 라이브러리 안에 있어야 한다. 
하지만 람다가 없다면 컬렉션을 편리하게 처리할 수 있는 좋은 라이브러리를 제공하기 힘들다.

그에 따라 자바에서 쓰기 편한 컬렉션 라이브러리가 적었으며, 
그에 따라 자바 개발자들은 필요한 컬렉션 기능을 직접 작성하곤 했다.
코틀린에서는 이런 습관을 버려야 한다.

```kotlin
data class Person(val name: String, val age: Int)
```

사람들로 이뤄진 리스트가 있고 그중에 가장 연장자를 찾고 싶다. 
람다를 사용해본 경험이 없는 개발자라면 루프를 써서 직접 검색을 구현할 것이다.

```kotlin
fun findTheOldest(people: List<Person>) {
    var maxAge = 0  // 가장 많은 나이를 저장한다.
    var theOldest: Person? = null   // 가장 연장자인 사람을 저장한다.
    for (person in people) {
        // 현재까지 발견한 최연장자보다 더 나이가 많은 사람을 찾으면 최댓값을 바꾼다.
        if (person.age > maxAge) {
            maxAge = person.age
            theOldest = person
        }
    }
    println(theOldest)
}

>>> val people = listOf(Person("Alice", 29), Person("Bob", 31))
>>> findTheOldest(people)
Person(name=Bob, age=31)
```
코틀린에서는 더 좋은 방법이 있다. 라이브러리 함수를 쓰면 된다.

```kotlin
>>> val people = listOf(Person("Alice", 29), Person("Bob", 31))
>>> println(people.maxBy { it.age }) // 나이 프로퍼티를 비교해서 값이 가장 큰 원소 찾기
Person(name=Bob, age=31)
```

- maxBy : 가장 큰 원소를 찾기 위해 비교에 사용할 값을 돌려주는 함수
- { it.age } : 바로 비교에 사용할 값을 돌려주는 함수 (it이 그 인자를 가리킨다.)

이 예제에서는 컬렉션의 원소가 Person 객체였으므로 이 함수가 반환하는 값은 Person 객체의 age 필드에 저장된 나이 정보다.

```kotlin
people.maxBy(Person::age)
```

<br/>


## 5.1.3. 람다 식의 문법

람다는 값처럼 여기저기 전달할 수 있는 동작의 모음이다.
람다를 선언해서 변수에 저장할 수도 있다.
하지만 함수에 인자로 넘기면서 바로 람다를 정의하는 경우가 대부분이다.

```
  파라미터             본문
{ x: Int, y: Int -> x + y }
항상 중괄호 사이에 위치함
```

코틀린 람다 식은 항상 중괄호로 둘러싸여 있다. 화살표(→) 가 인자 목록과 람다 본문을 구분해준다.
람다 식은 변수에 저장할 수 있다. 람다가 저장된 변수를 다른 일반 함수와 마찬가지로 다룰 수 있다.

```kotlin
>>> val sum = { x: Int, y: Int -> x + y }
>>> println(sum(1, 2))
3
```

원한다면 람다 식을 직접 호출해도 된다.

```kotlin
>>> { println(42) } ()
42
```

하지만 이런 코드는 그다지 쓸모가 없다. 
만약 이렇게 코드의 일부분을 블록으로 둘러싸 실행할 필요가 있다면 run을 사용한다. 
`run`은 인자로 받은 람다를 실행해주는 라이브러리 함수이다.
실행 시점에 코틀린 람다 호출에는 아무 부가 비용이 들지 않으며, 프로그램의 기본 구성요소와 비슷한 성능을 낸다.

```kotlin
>>> run { println(42) } // 람다 본문에 있는 코드를 실행한다.
42
```
```kotlin
>>> val people = listOf(Person("Alice", 29), Person("Bob", 31))
>>> println(people.maxBy { it.age })
Person(name=Bob, age=31)
```

이 예제에서 코틀린이 코드를 줄여 쓸 수 있게 제공했던 기능을 제거하고 정식으로 람다를 작성하면 다음과 같다.

```kotlin
people.maxBy({p: Person -> p.age})
```
중괄호 안에 있는 코드는 람다 식이고 그 람다 식을 maxBy 함수에 넘긴다.
람다 식은 Person 타입의 값을 인자로 받아서 인자의 age를 반환한다.

하지만 이 코드는 번잡하다. 우선 구분자가 너무 많이 쓰여서 가독성이 떨어진다. 
그리고 컴파일러가 문맥으로부터 유추할 수 있는 인자 타입을 굳이 적을 필요는 없다. 
마지막으로 인자가 단 하나뿐인 경우 인자에 이름을 붙이지 않아도 된다.

먼저 중괄호부터 시작하면 코틀린에는 함수 호출 시 맨 뒤에 있는 인자가 람다 식이라면 
그 람다를 괄호 밖으로 빼낼 수 있다는 문법 관습이 있다. 이 예제에서는 람다가 유일한 인자이므로 마지막 인자이기도 하다. 
따라서 괄호 뒤에 람다를 둘 수 있다.

```kotlin
people.maxBy() { p: Person -> p.age }
```

이 코드처럼 람다가 어떤 함수의 유일한 인자이고 괄호 뒤에 람다를 썼다면 호출 시 빈 괄호를 없애도 된다.

```kotlin
people.maxBy { p: Person -> p.age }
```

람다가 함수의 유일한 인자라면 괄호 없이 람다를 바로 쓰기 원할 것이다.
인자가 여럿 있는 경우에는 람다를 밖으로 빼낼 수도 있고 람다를 괄호 안에 유지해서 함수의 인자임을 분명히 할 수도 있다.
둘 이상의 람다를 인자로 받는 함수라고 해도 인자 목록의 맨 마지막 람다만 밖으로 뺄 수 있다.
따라서 그런 경우에는 괄호를 사용하는 일반적인 함수 호출 구문을 사용하는 편이 낫다.

```kotlin
>>> val people = listOf(Person("이몽룡", 29), Person("성춘향", 31))
>>> val names = people.joinToString(separator = " ", transform = { p: Person -> p.name })
>>> println(names)
이몽룡 성춘향
```

이 함수 호출에서 함수를 괄호 밖으로 뺀 모습은 다음과 같다.

```kotlin
people.joinToString(" ") { p: Person -> p.name }
```

처음 코드는 이름 붙은 인자를 사용해 람다를 넘김으로써 람다를 어떤 용도로 쓰는지 더 명확히 했다.
다음 코드는 더 간결하지만 람다의 용도를 분명히 알아볼 수는 없다.

```kotlin
people.maxBy { p: Person -> p.age } // 파라미터 타입을 명시
people.maxBy { p -> p.age } // 파라미터 타입을 생략(컴파일러가 추론)
```

maxBy 함수의 경우 파라미터의 타입은 항상 컬렉션 원소 타입과 같다.
컴파일러는 여러분이 Person 타입의 객체가 들어있는 컬렉션에 대해 maxBy를 호출한다는 사실을 알고 있으므로 
람다의 파라미터도 Person이라는 사실을 이해할 수 있다.

람다의 파라미터 이름을 디폴트 이름인 it으로 바꾸면 람다 식을 더 간단하게 만들 수 있다.
람다의 파라미터가 하나뿐이고 그 타입을 컴파일러가 추론할 수 있는 경우 it을 바로 쓸 수 있다.

```kotlin
people.maxBy { it.age } // "it"은 자동 생성된 파라미터 이름이다.
```

람다 파라미터 이름을 따로 지정하지 않은 경우에만 it이라는 이름이 자동으로 만들어진다.


> it을 사용하는 관습은 코드를 아주 간단하게 만들어준다.
하지만 이를 남용하면 안된다.
**특히 람다 안에 람다가 중첩되는 경우 각 람다의 파라미터를 명시하는 편이 낫다.**
파라미터를 명시하지 않으면 각각의 it이 가리키는 파라미터가 어떤 람다에 속했는지 파악하기 어려울 수 있다.
문맥에서 람다 파라미터의 의미나 파라미터의 타입을 쉽게 알 수 없는 경우에도 파라미터를 명시적으로 선언하면 도움이 된다.

람다를 변수에 저장할 때는 파라미터의 타입을 추론할 문맥이 존재하지 않는다.
따라서 파라미터 타입(여기서는 Person)을 명시해야 한다.

```kotlin
>>> val getAge = { p: Person -> p.age }
>>> people.maxBy(getAge)
```

본문이 여러 줄로 이뤄진 경우 본문의 맨 마지막에 있는 식이 람다의 결과 값이 된다.

```kotlin
>>> val sum = { x: Int, y: Int ->
println("Computing the sum of $x and $y...")
x + y
}
>>> println(sum(1,2))
```

<br/>


## 5.1.4. 현재 영역에 있는 변수에 접근

자바 메소드 안에서 무명 내부 클래스를 정의할 때 메소드의 로컬 변수를 무명 내부 클래스에서 사용할 수 있다.
람다 안에서도 같은 일을 할 수 있다.
람다를 함수 안에서 정의하면 함수의 파라미터뿐 아니라 람다 정의의 앞에 선언된 로컬 변수까지 람다에서 모두 사용할 수 있다.

```kotlin
fun printMessageWithPrefix(message: Collection<String>, prefix: String) {
    message.forEach {   // 각 원소에 대해 수행할 작업을 람다로 받는다.
        println("$prefix $it")  // 람다 안에서 함수의 "prefix" 파라미터를 사용한다.
    }
}

>>> val errors = listOf("403 Forbidden", "404 Not Found")
>>> printMessageWithPrefix(errors, "Error:")
Error: 403 Forbidden
Error: 404 Not Found
```

자바와 다른 점 중 중요한 한 가지는 코틀린 람다 안에서는 파이널 변수가 아닌 변수에 접근할 수 있다는 점이다.
또한 람다 안에서 바깥의 변수를 변경해도 된다.
다음 코드는 전달받은 상태 코드 목록에 있는 클라이언트와 서버 오류의 횟수를 센다.

```kotlin
fun printProblemCounts(responses: Collection<String>) {
    var clientErrors = 0
    var serverErrors = 0
    responses.forEach {
        if (it.startsWith("4")) {
            clientErrors++
        } else if (it.startsWith("5")) {
            serverErrors++
        }
    }
    println("$clientErrors client errors, $serverErrors server errors")
}

>>> val responses = listOf("200 OK", "418 I'm a teapot", "500 Internal Server Error")
>>> printProblemCounts(responses)
1 client errors, 1 server errors
```

코틀린에서는 자바와 달리 람다에서 람다 밖 함수에 있는 파이널이 아닌 변수에 접근할 수 있고, 그 변수를 변경할 수도 있다.
이 예제의 prefix, clientErrors, serverErrors와 같이 람다 안에서 사용하는 외부 변수를 
**람다가 포획(capture)한 변수**라고 부른다.

> `클로저`(closure)
> - 람다를 실행 시점에 표현하는 데이터 구조는...
>   - 람다에서 시작하는 모든 참조가 닫힌 객체 그래프를 람다 코드와 함께 저장해야 한다.
> - 함수를 쓸모 있는 1급 시민으로 만드려면 포획한 변수를 제대로 처리해야 하고, 
>   포획한 변수를 제대로 저리하려면 클로저가 꼭 필요하다.
> - 그래서 람다를 클로저라고 부르기도 한다.
> - 람다, 무명 함수, 함수 리터럴, 클로저를 서로 혼용하는 일이 많다.

기본적으로 함수 안에 정의된 로컬 변수의 생명주기는 함수가 반환되면 끝난다.
하지만 어떤 함수가 자신의 로컬 변수를 포획한 람다를 반환하거나 다른 변수에 저장한다면 
로컬 변수의 생명주기와 함수의 생명주기가 달라질 수 있다.

포획한 변수가 있는 람다를 저장해서 함수가 끝난 뒤에 실행해도 람다의 본문 코드는 여전히 포획한 변수를 읽거나 쓸 수 있다. 
어떻게 그런 동작이 가능할까?
파이널 변수를 포획한 경우에는 람다 코드를 변수 값과 함께 저장한다.
파이널이 아닌 변수를 포획한 경우에는 변수를 특별한 래퍼로 감싸서 나중에 변경하거나 읽을 수 있게 한 다음, 
래퍼에 대한 참조를 람다 코드와 함께 저장한다.

> ### ✅변경 가능한 변수 포획하기: 자세한 구현 방법
> 자바에서는 파이널 변수만 포횔할 수 있다.
하지만 교묘한 속임수를 통해 변경 가능한 변수를 포획할 수 있다.
그 속임수는 변경 가능한 변수를 저장하는 원소가 단 하나뿐인 배열을 선언하거나, 
변경 가능한 변수를 필드로 하는 클래스를 선언하는 것이다
(안에 들어있는 원소는 변경 가능할지라도 배열이나 클래스의 인스턴스에 대한 참조를 final로 만들면 포획이 가능하다).
이런 속임수를 코틀린으로 작성하면 다음과 같다.
> ```kotlin
> class Ref<T>(var value: T) // 변경 가능한 변수를 포획하는 방법을 보여주기 위한 클래스
> 
> >>> val counter = Ref(0)
> 
> // 공식적으로 변경 불가능한 변수를 포획했지만 그 변수가 가리키는 객체의 필드 값을 바꿀 수 있다.
> >>> val inc = { counter.value++ }
> ```
> 실제 코드에서는 이런 래퍼를 만들지 않아도 된다.
대신, 변수를 직접 바꾼다.
> ```kotlin
> var counter = 0
> var inc = { counter++ }
> ```
> 이 코틀린 코드가 어떻게 작동할까?
첫 번째 예제는 두 번째 예제가 작동하는 내부 모습을 보여준다.
람다가 파이널 변수(val)를 포획하면 자바와 마찬가지로 그 변수의 값이 복사된다.
하지만 람다가 변경 가능한 변수(var)를 포획하면 변수를 Ref 클래스 인스턴스에 넣는다.
그 Ref 인스턴스에 대한 참조를 파이널로 만들면 쉽게 람다로 포획할 수 있고, 
람다 안에서는 Ref 인스턴스의 필드를 변경할 수 있다.

한 가지 꼭 알아둬야 할 함정이 있다.
람다를 이벤트 핸들러나 다른 비동기적으로 실행되는 코드로 활용하는 경우 
함수 호출이 끝난 다음에 로컬 변수가 변경될 수도 있다.
예를 들어 다음 코드는 버튼 클릭 횟수를 제대로 셀 수 없다.

```kotlin
fun tryToCountButtonClicks(button: Button): Int {
    var clicks = 0
    button.onClick { clicks++ }
    return clicks
}
```

이 함수는 항상 0을 반환한다.
onClick 핸들러는 호출될 때마다 clicks의 값을 증가시키지만 그 값의 변경을 관찰할 수는 없다.
핸들러는 tryToCountButtonClicks가 clicks를 반환한 다음에 호출되기 때문이다.
이 함수를 제대로 구현하려면 클릭 횟수를 세는 카운터 변수를 함수의 내부가 아니라 
클래스의 프로퍼티나 전역 프로퍼티 등의 위치로 빼내서 나중에 변수 변화를 살펴볼 수 있게 해야 한다.

<br/>


## 5.1.5. 

<br/>


## 5.2.

<br/>


## 5.2.

<br/>


## 5.2.

<br/>




<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>